/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useCallback, useEffect, useRef, useState } from "react";
import { GroupProps, useFrame, useThree } from "@react-three/fiber";
import { Points, useGLTF } from "@react-three/drei";
import { MeshSurfaceSampler } from "three/examples/jsm/math/MeshSurfaceSampler";
import {
    galaxyFragmentShader,
    galaxyVertexShader,
} from "../shader/GalaxyMaterial";

class GalaxyProps {
    count: number;
    size: number;
    radius: number;
    branches: number;
    spin: number;
    randomness: number;
    randomnessPower: number;
    insideColor: THREE.Color;
    outsideColor: THREE.Color;
}

export default function Galaxy({ ...props }: GalaxyProps) {
    const { scene, gl } = useThree();

    const pointRef = useRef<THREE.Points>(null);

    const [positions, setPositions] = useState<Float32Array>(
        new Float32Array(props.count * 3)
    );
    const [randomness, setRandomness] = useState<Float32Array>(
        new Float32Array(props.count * 3)
    );
    const [colors, setColors] = useState<Float32Array>(
        new Float32Array(props.count * 3)
    );
    const [scales, setScales] = useState<Float32Array>(
        new Float32Array(props.count)
    );

    const [loading, setLoading] = useState<boolean>(true);

    const geometry = useCallback(() => {
        if (!loading) {
            const _geometry = new THREE.BufferGeometry();

            _geometry.setAttribute(
                "position",
                new THREE.BufferAttribute(positions, 3)
            );
            _geometry.setAttribute(
                "aRandomness",
                new THREE.BufferAttribute(randomness, 3)
            );
            _geometry.setAttribute(
                "color",
                new THREE.BufferAttribute(colors, 3)
            );
            _geometry.setAttribute(
                "aScale",
                new THREE.BufferAttribute(scales, 1)
            );

            return _geometry;
        }

        return null;
    }, [loading]);

    const material = useCallback(() => {
        const _material = new THREE.ShaderMaterial({
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexColors: true,
            uniforms: {
                uTime: { value: 0 },
                uSize: { value: 30 * gl.getPixelRatio() },
            },
            vertexShader: galaxyVertexShader,
            fragmentShader: galaxyFragmentShader,
        });
        return _material;
    }, []);

    useEffect(() => {
        for (let i = 0; i < props.count; i++) {
            const i3 = i * 3;

            // Position
            const radius = Math.random() * props.radius;

            const branchAngle =
                ((i % props.branches) / props.branches) * Math.PI * 2;

            const randomX =
                Math.pow(Math.random(), props.randomnessPower) *
                (Math.random() < 0.5 ? 1 : -1) *
                props.randomness *
                radius;
            const randomY =
                Math.pow(Math.random(), props.randomnessPower) *
                (Math.random() < 0.5 ? 1 : -1) *
                props.randomness *
                radius;
            const randomZ =
                Math.pow(Math.random(), props.randomnessPower) *
                (Math.random() < 0.5 ? 1 : -1) *
                props.randomness *
                radius;

            positions.set(
                [
                    Math.cos(branchAngle) * radius,
                    0,
                    Math.sin(branchAngle) * radius,
                ],
                i3
            );

            randomness.set([randomX, randomY, randomZ], i3);

            // Color
            const mixedColor = props.insideColor.clone();
            mixedColor.lerp(props.outsideColor, radius / props.radius);

            colors.set([mixedColor.r, mixedColor.g, mixedColor.b], i3);

            // Scale
            scales.set([Math.random()], i);
        }

        setPositions(positions);
        setRandomness(randomness);
        setColors(colors);
        setScales(scales);
        setLoading(false);
    }, []);

    useFrame(({ clock }) => {
        if (pointRef?.current?.material["uniforms"]) {
            pointRef.current.material["uniforms"].uTime.value =
                clock.getElapsedTime();
        }
    });

    return (
        <>
            <mesh>
                <Points
                    ref={pointRef}
                    material={material()}
                    geometry={geometry()}
                />
            </mesh>
        </>
    );
}

// useGLTF.preload("/models/saturn.glb");
