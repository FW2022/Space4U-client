/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useCallback, useEffect, useRef, useState } from "react";
import { GroupProps, useFrame, useThree } from "@react-three/fiber";
import { Points, useGLTF } from "@react-three/drei";
import { PointShaderMaterialRaw } from "../../shader/PointShaderMaterial";
import { MeshSurfaceSampler } from "three/examples/jsm/math/MeshSurfaceSampler";

class SaturnModelProps {
    numParticles: number;
    path: string;
    color1: THREE.ColorRepresentation;
    color2: THREE.ColorRepresentation;
}

export default function PointModel({
    ...props
}: SaturnModelProps & GroupProps) {
    const { scene } = useThree();

    const gltf = useGLTF(props.path);

    const meshRef = useRef<THREE.Mesh>(null);
    const pointsRef = useRef<THREE.Points>(null);
    const group = useRef<THREE.Group>(null);

    const sampler = useRef<MeshSurfaceSampler>(null);
    const [particlesPosition, setParticlesPosition] = useState<Float32Array>(
        new Float32Array(props.numParticles * 3)
    );
    const [particlesRandomness, setParticlesRandomness] =
        useState<Float32Array>(new Float32Array(props.numParticles * 3));

    const [loading, setLoading] = useState<boolean>(true);

    const particlesGeometry = useCallback(() => {
        if (!loading) {
            const particlesBufferGeometry = new THREE.BufferGeometry();

            particlesBufferGeometry.setAttribute(
                "position",
                new THREE.BufferAttribute(particlesPosition, 3)
            );
            particlesBufferGeometry.setAttribute(
                "aRandom",
                new THREE.BufferAttribute(particlesRandomness, 3)
            );

            // console.log(particlesBufferGeometry);

            return particlesBufferGeometry;
        }
        return null;
    }, [loading]);

    useFrame(({ clock }) => {
        // @ts-ignore
        if (pointsRef?.current?.material?.uniforms) {
            // @ts-ignore
            pointsRef.current.material.uniforms.uTime.value =
                clock.getElapsedTime();
        }
    });

    useEffect(() => {
        // console.log("SaturnModel useEffect");
        // console.log(gltf);
        sampler.current = new MeshSurfaceSampler(meshRef.current).build();
        // setSampler(new MeshSurfaceSampler(meshRef.current).build());

        for (let i = 0; i < props.numParticles; i++) {
            const newPosition = new THREE.Vector3();
            sampler.current.sample(newPosition);
            particlesPosition.set(
                [
                    newPosition.x, // 0 - 3
                    newPosition.y, // 1 - 4
                    newPosition.z, // 2 - 5
                ],
                i * 3
            );

            particlesRandomness.set(
                [
                    Math.random() * 2 - 1, // -1 ~ 1
                    Math.random() * 2 - 1, // -1 ~ 1
                    Math.random() * 2 - 1, // -1 ~ 1
                ],
                i * 3
            );
        }

        setParticlesPosition(particlesPosition);
        setParticlesRandomness(particlesRandomness);
        setLoading(false);
    }, []);

    return (
        <>
            <group ref={group} {...props} dispose={null}>
                <mesh
                    ref={meshRef}
                    visible={false}
                    // @ts-ignore
                    geometry={gltf.scene.children[0].geometry}
                />
                <Points
                    ref={pointsRef}
                    material={PointShaderMaterialRaw(
                        props.color1,
                        props.color2
                    )}
                    geometry={particlesGeometry()}
                />
            </group>
        </>
    );
}

// useGLTF.preload("/models/saturn.glb");
