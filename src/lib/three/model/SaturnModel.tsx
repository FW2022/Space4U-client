/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, {
    useCallback,
    useEffect,
    useMemo,
    useRef,
    useState,
} from "react";
import { extend, PointsProps, useFrame, useThree } from "@react-three/fiber";
import { Points, useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { PointShaderMaterialRaw } from "../../shader/PointShaderMaterial";
import { MeshSurfaceSampler } from "three/examples/jsm/math/MeshSurfaceSampler";

type GLTFResult = GLTF & {
    nodes: {
        Saturn001: THREE.Mesh;
    };
    materials: {
        ["None.002"]: THREE.MeshStandardMaterial;
    };
};

class SaturnModelProps {
    numParticles: number;
}

export default function Model({ ...props }: SaturnModelProps & PointsProps) {
    const { scene } = useThree();

    const { nodes } = useGLTF("/models/saturn.glb") as GLTFResult;

    const meshRef = useRef<THREE.Mesh>(null);
    const pointsRef = useRef<THREE.Points>(null);
    const group = useRef<THREE.Group>(null);

    const sampler = useRef<MeshSurfaceSampler>(null);
    const [particlesPosition, setParticlesPosition] = useState<Float32Array>(
        new Float32Array(props.numParticles * 3)
    );
    const [particlesRandomness, setParticlesRandomness] =
        useState<Float32Array>(new Float32Array(props.numParticles * 3));

    const [loading, setLoading] = useState<boolean>(true);

    const particlesGeometry = useCallback(() => {
        if (!loading) {
            const particlesBufferGeometry = new THREE.BufferGeometry();

            particlesBufferGeometry.setAttribute(
                "position",
                new THREE.BufferAttribute(particlesPosition, 3)
            );
            particlesBufferGeometry.setAttribute(
                "aRandom",
                new THREE.BufferAttribute(particlesRandomness, 3)
            );

            console.log(particlesBufferGeometry);

            return particlesBufferGeometry;
        }
        return null;
    }, [loading]);

    useFrame(({ clock }) => {
        // @ts-ignore
        if (pointsRef?.current?.material?.uniforms) {
            // @ts-ignore
            pointsRef.current.material.uniforms.uTime.value =
                clock.getElapsedTime();
        }
    });

    useEffect(() => {
        console.log("SaturnModel useEffect");
        sampler.current = new MeshSurfaceSampler(meshRef.current).build();
        // setSampler(new MeshSurfaceSampler(meshRef.current).build());

        for (let i = 0; i < props.numParticles; i++) {
            const newPosition = new THREE.Vector3();
            sampler.current.sample(newPosition);
            particlesPosition.set(
                [
                    newPosition.x, // 0 - 3
                    newPosition.y, // 1 - 4
                    newPosition.z, // 2 - 5
                ],
                i * 3
            );

            particlesRandomness.set(
                [
                    Math.random() * 2 - 1, // -1 ~ 1
                    Math.random() * 2 - 1, // -1 ~ 1
                    Math.random() * 2 - 1, // -1 ~ 1
                ],
                i * 3
            );
        }

        setParticlesPosition(particlesPosition);
        setParticlesRandomness(particlesRandomness);
        setLoading(false);
    }, []);

    return (
        <>
            <group ref={group} dispose={null} visible={false}>
                <mesh ref={meshRef} geometry={nodes.Saturn001.geometry} />
            </group>
            <Points
                {...props}
                ref={pointsRef}
                material={PointShaderMaterialRaw("red", "yellow")}
                geometry={particlesGeometry()}
            ></Points>
        </>
    );
}

useGLTF.preload("/models/saturn.glb");
