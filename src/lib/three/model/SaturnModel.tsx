/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useCallback, useEffect, useMemo, useRef } from "react";
import { extend, PointsProps, useFrame } from "@react-three/fiber";
import { Points, useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { PointShaderMaterialRaw } from "../../shader/PointShaderMaterial";
import { MeshSurfaceSampler } from "three/examples/jsm/math/MeshSurfaceSampler";

type GLTFResult = GLTF & {
    nodes: {
        Saturn001: THREE.Mesh;
    };
    materials: {
        ["None.002"]: THREE.MeshStandardMaterial;
    };
};

export default function Model({ ...props }: PointsProps) {
    const { nodes, materials } = useGLTF("/models/saturn.glb") as GLTFResult;

    const meshRef = useRef<THREE.Mesh>(null);
    const pointsRef = useRef<THREE.Points>(null);
    const group = useRef<THREE.Group>();

    const particlesGeometry = useCallback(() => {
        if (meshRef?.current) {
            const sampler = new MeshSurfaceSampler(meshRef.current).build();
            const numParticles = 20000;
            const _particlesGeometry = new THREE.BufferGeometry();
            const particlesPosition = new Float32Array(numParticles * 3);
            const particlesRandomness = new Float32Array(numParticles * 3);

            for (let i = 0; i < numParticles; i++) {
                const newPosition = new THREE.Vector3();
                sampler.sample(newPosition);
                particlesPosition.set(
                    [
                        newPosition.x, // 0 - 3
                        newPosition.y, // 1 - 4
                        newPosition.z, // 2 - 5
                    ],
                    i * 3
                );

                particlesRandomness.set(
                    [
                        Math.random() * 2 - 1, // -1 ~ 1
                        Math.random() * 2 - 1, // -1 ~ 1
                        Math.random() * 2 - 1, // -1 ~ 1
                    ],
                    i * 3
                );
            }

            _particlesGeometry.setAttribute(
                "position",
                new THREE.BufferAttribute(particlesPosition, 3)
            );
            _particlesGeometry.setAttribute(
                "aRandom",
                new THREE.BufferAttribute(particlesRandomness, 3)
            );

            group.current.visible = false;

            return _particlesGeometry;
        }
        return null;
    }, [meshRef]);

    useFrame(({ clock }) => {
        // @ts-ignore
        if (pointsRef?.current?.material?.uniforms) {
            // @ts-ignore
            pointsRef.current.material.uniforms.uTime.value =
                clock.getElapsedTime();
        }
    });

    return (
        <>
            <group ref={group} dispose={null}>
                <mesh
                    ref={meshRef}
                    geometry={nodes.Saturn001.geometry}
                    material={materials["None.002"]}
                />
            </group>
            {/* https://github.com/pmndrs/drei/issues/773 */}
            <Points
                {...props}
                ref={pointsRef}
                geometry={particlesGeometry()}
                material={PointShaderMaterialRaw("red", "yellow")}
            />
        </>
    );
}

useGLTF.preload("/models/saturn.glb");
